シーンのマッチングによるロボットナビゲーション

ロボットが目的地まで移動する場合、ロボット現在の位置を知る必要がある。
これをポジショニングと言う。たとえばLiDARなどのセンサーを用いる場合、
ポジショニングは環境の3Dデータを持つ地図と、現在の環境の形状を３次元的
に照合することなどでポジショニングを行う。しかし人間は周囲の風景を見て、
自分の位置を知るので、ロボットも人間と同様に、カメラで周囲の風景を撮影
した画像を照合することで、ポジショニングが行えないかを実験する。

照合のリファレンスとなる画像は、ある経路に沿って連続して撮影した画像群
を用いることにする。それらに対し、経路上の一つの場所で別の時刻に撮影し
た画像を照合し、照合結果から経路上の位置を知ることができるかを試す。今、
リファレンスの画像群が100枚あるとし、それらを経路の順位に R001, R002,
R003, ..., R100とする。そしてたとえば R030 と同一場所で違う時刻に撮影
した画像を S030 とする。S030 と R001, R002, ... の類似度を順次計算して
行くと、R030 に近づくにしたがって類似度が増し、R030 で最高になることが
期待される。このようなことが起これば、類似度の最高になるリファレンス画
像から、ロボットの位置が推定される。これを実験により確かめる。

ここで画像の類似度を計算するのには、テンプレートマッチングという手法を
用いるが、同じ場所の風景でも時刻や天候が異なれば、風景が同じ画像として
撮影されることは無い。したがってこのような風景の変化には影響されず、し
かし風景が持つ基本的な情報をうまく引き出して類似度を計算する手法が望ま
れる。テンプレートマッチングで類似度を計算する方法は多数あり、SSD,
SAD, NCC, ZNCC などがある。
https://algorithm.joho.info/image-processing/template-matching-sad-ssd-ncc/
また画像をそのまま使用するのではなく、エッジ画像に変換してからテンプレー
トマッチングを行う方が、ここでの目的には合致するかも知れない。これらを
実験する。

　すぐに使える実験画像は
http://www.cs.gunma-u.ac.jp/~ohta/2017_06_12_13_25_11_JPG.zip
http://www.cs.gunma-u.ac.jp/~ohta/2017_06_08_10_34_48_JPG.zip
にある。これらは別の日に同一のコースを自動車から撮影した画像群である。
一つをリファレンス画像として用い、もう一方の画像群から１枚を取り出して
照合対象画像とする。ここでは自動車を想定している訳ではないが、まずはこ
れを使用してみると良い。しかし、後にはつくばチャレンジ用ロボットで撮影
した画像を用いてみるのが良い。

　small.cpp は以下の「1.白黒小サイズ画像への変換」、match.cpp は「2.テ
ンプレートマッチングの実行」の参考プログラムである。

1. 白黒小サイズ画像への変換
　画像は一般にカラー画像であるが、テンプレートマッチングでは白黒画像を
用いる。カラー⇒白黒変換は、OpenCVの画像読み込み関数 imread() の第２引
数にIMREAD_GRAYSCALEを指定することで、白黒画像として読み込むことができ
る。またカメラで撮影した画像の画素数は幅、高さとも1000以上が普通である
が、シーンのマッチングにはに細かすぎるため、幅および高さの大きさを100
程度まで縮小する。これには関数resize()を用いれば良い。ただしエイリアシ
ングを防ぐために resize() を実行する前に、関数 GaussianBlur() を用いて
スムージングしておく。なお画像は風景が写っている画像領域のみを使用する
こと。
http://opencv.jp/opencv-2svn/cpp/highgui_reading_and_writing_images_and_video.html?highlight=imread#cv-imread
http://opencv.jp/opencv-2svn/cpp/imgproc_image_filtering.html?highlight=gaussianblur#GaussianBlur
http://opencv.jp/opencv-2svn/cpp/imgproc_geometric_image_transformations.html?highlight=resize#resize

2. テンプレートマッチングの実行
　テンプレートマッチングは関数 matchTemplate() で行うことができる。リ
ファレンス画像を第１引数、照合対象画像を第２引数で与えるテンプレートと
して実行する。この際、画像のサイズを100x100画素程度とすると、プレート
は中央部分の80x80程度とする。これは風景を撮影するカメラの向きが多少異
なっていてもそれを許容する照合を行うためである。テンプレートマッチング
の結果はこの関数の第３引数にfloatの画像として得られる。この結果画像の
画素地の最大類似度を、画像全体の照合結果とする。関数 matchTemplate()
は第４引数としてテンプレートマッチングの手法を指定することができる。こ
の指定を変えて、どの手法がここでの目的に好ましいかを実験する。
http://opencv.jp/opencv-2svn/cpp/imgproc_object_detection.html?highlight=matchtemplate#matchTemplate

3. 特徴画像を用いた類似度計算
　画像のエッジなどは照明変化の影響を受けにくい。そこで画像をそのままテ
ンプレートマッチングするのではなく、エッジ画像に変換してからテンプレー
トマッチングを行った方が安定した照合ができるかもしれない。ここではそれ
を試す。エッジ画像を作成するにはには関数 sobel() や canny() を用いる。
これらを現画像に施した結果をリファレンス画像およびテンプレート画像とし
てテンプレートマッチングを行う。
http://opencv.jp/opencv-2svn/cpp/imgproc_image_filtering.html?highlight=sobel#Sobel
http://opencv.jp/opencv-2svn/cpp/imgproc_feature_detection.html?highlight=canny#Canny

4. 様々な画像特徴を用いた実験
　照明変化に堅牢な画像特徴として　LBP(Local Binary Pattern)特徴なども
考案されている。インターネットで調べると情報が得られる。このような特徴
を用いた照合も試してみると良い。
